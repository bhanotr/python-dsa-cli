=== HINT LEVEL ===

Hint Level 1:

General approach:
- Use Kadane's algorithm
- Track current sum (local maximum)
- Track best sum (global maximum)
- At each position: extend or restart

Key concept:
- current_sum = max of (current element, current_sum + current element)
- best_sum = max(best_sum, current_sum)

Kadane's algorithm:
```python
current_sum = 0
best_sum = float('-inf')

for num in nums:
    current_sum = max(num, current_sum + num)
    best_sum = max(best_sum, current_sum)
```

=== HINT LEVEL ===

Hint Level 2:

Detailed approach for max_subarray():
1. Initialize current_sum = 0, best_sum = -infinity
2. For each num in nums:
   a. Decide: extend current or start new?
      - Extend: current_sum + num
      - Start new: num
      - Choose: max(num, current_sum + num)
   b. Update best_sum
3. Return best_sum

Example:
```python
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]

num=-2: current=max(-2, 0-2)=-2, best=-2
num=1:  current=max(1, -2+1)=1,   best=1
num=-3: current=max(-3, 1-3)=-2,  best=1
num=4:  current=max(4, -2+4)=4,   best=4
num=-1: current=max(-1, 4-1)=3,   best=4
num=2:  current=max(2, 3+2)=5,   best=5
num=1:  current=max(1, 5+1)=6,   best=6
num=-5: current=max(-5, 6-5)=1,   best=6
num=4:  current=max(4, 1+4)=5,   best=6

Result: 6
```

Decision rule:
- If current_sum is negative, starting fresh is better
- If current_sum is positive, extending might be better

=== HINT LEVEL ===

Hint Level 3:

Complete solution:
```python
from typing import List

def max_subarray(nums: List[int]) -> int:
    current_sum = 0
    best_sum = float('-inf')
    
    for num in nums:
        current_sum = max(num, current_sum + num)
        best_sum = max(best_sum, current_sum)
    
    return best_sum
```

Time complexity: O(n) - Single pass
Space complexity: O(1) - Constant extra space

Handling all negatives:
```python
nums = [-1, -2, -3]
num=-1: current=-1, best=-1
num=-2: current=-2, best=-1
num=-3: current=-3, best=-1

Result: -1 (the least negative)
```

The algorithm works for all cases!
- When all positive: extends everything
- When all negative: keeps finding the least negative
- Mixed: naturally switches to restart when beneficial

Brute force alternative (O(nÂ²)):
```python
def max_subarray(nums):
    best = float('-inf')
    for i in range(len(nums)):
        for j in range(i, len(nums)):
            best = max(best, sum(nums[i:j+1]))
    return best
```
Kadane's is much better!
