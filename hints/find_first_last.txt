=== HINT LEVEL ===

Hint Level 1:

General approach:
- Use binary search twice
- First search: find first occurrence
- Second search: find last occurrence
- Binary search modifications for boundaries

Key concept:
- Standard binary search finds ANY occurrence
- To find FIRST: keep searching left when found
- To find LAST: keep searching right when found

Binary search template:
```python
left, right = 0, len(nums) - 1
while left <= right:
    mid = (left + right) // 2
    if nums[mid] == target:
        # Found! But don't stop yet
        # Continue searching in one direction
    elif nums[mid] < target:
        left = mid + 1
    else:
        right = mid - 1
```

=== HINT LEVEL ===

Hint Level 2:

Detailed approach for find_first_last():
1. Define helper function for binary search
2. Find first position:
   - When found, search left half (right = mid - 1)
   - Track the position found
3. Find last position:
   - When found, search right half (left = mid + 1)
   - Track the position found
4. Return [first, last] or [-1, -1] if not found

Finding first:
```python
def find_first(nums, target):
    left, right = 0, len(nums) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            result = mid
            right = mid - 1  # Keep searching left
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

Finding last:
```python
def find_last(nums, target):
    left, right = 0, len(nums) - 1
    result = -1
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            result = mid
            left = mid + 1  # Keep searching right
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return result
```

=== HINT LEVEL ===

Hint Level 3:

Complete solution:
```python
from typing import List

def find_first_last(nums: List[int], target: int) -> List[int]:
    def find_first(nums, target):
        left, right = 0, len(nums) - 1
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                result = mid
                right = mid - 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return result
    
    def find_last(nums, target):
        left, right = 0, len(nums) - 1
        result = -1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                result = mid
                left = mid + 1
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return result
    
    if not nums:
        return [-1, -1]
    
    first = find_first(nums, target)
    if first == -1:
        return [-1, -1]
    
    last = find_last(nums, target)
    return [first, last]
```

Time complexity: O(log n) + O(log n) = O(log n)
Space complexity: O(1) - Constant extra space
