=== HINT LEVEL ===

Hint Level 1:

General approach:
- Use two pointers (slow and fast)
- Slow pointer: position for next unique element
- Fast pointer: scans through array
- Array is sorted, so duplicates are adjacent

Key concept:
- Since array is sorted, duplicates are next to each other
- Compare nums[fast] with nums[slow]
- If different, place at slow + 1

Two pointers:
```python
slow = 0
for fast in range(1, len(nums)):
    if nums[fast] != nums[slow]:
        slow += 1
        nums[slow] = nums[fast]
```

=== HINT LEVEL ===

Hint Level 2:

Detailed approach for remove_duplicates():
1. If array is empty, return 0
2. Initialize slow = 0
3. For fast from 1 to end:
   a. If nums[fast] != nums[slow]:
      - slow += 1
      - nums[slow] = nums[fast]
4. Return slow + 1 (number of unique elements)

Example:
```python
nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]

slow=0, fast=1: nums[1]==nums[0], skip
slow=0, fast=2: nums[2]!=nums[0], slow=1, nums[1]=1
slow=1, fast=3: nums[3]==nums[1], skip
slow=1, fast=4: nums[4]==nums[1], skip
slow=1, fast=5: nums[5]!=nums[1], slow=2, nums[2]=2
slow=2, fast=6: nums[6]==nums[2], skip
slow=2, fast=7: nums[7]!=nums[2], slow=3, nums[3]=3
...

After: [0, 1, 2, 3, 4, 2, 2, 3, 3, 4]
       ^^^^^^^^ these 5 are correct
Return: 5
```

=== HINT LEVEL ===

Hint Level 3:

Complete solution:
```python
from typing import List

def remove_duplicates(nums: List[int]) -> int:
    if not nums:
        return 0
    
    slow = 0
    for fast in range(1, len(nums)):
        if nums[fast] != nums[slow]:
            slow += 1
            nums[slow] = nums[fast]
    
    return slow + 1
```

Time complexity: O(n) - Single pass
Space complexity: O(1) - In-place modification

Understanding the in-place nature:
```python
# Problem doesn't care about elements after index k
# Only first k elements need to be correct
[1, 1, 2, 2, 3] -> [1, 2, 2, 2, 3] (k=2)
                       ^^^^
                   first 2 correct, rest doesn't matter
```

Alternative (less efficient):
```python
def remove_duplicates(nums):
    return len(list(dict.fromkeys(nums)))
```
This doesn't modify in-place!

Why this works:
- Array is sorted, so duplicates are adjacent
- We only compare with last unique element
- We overwrite as we go, which is fine for in-place
