1: === HINT LEVEL ===

Hint Level 1:

General approach:
- Use dictionary to group IPs by network prefix
- Extract network prefix from IP (first 3 octets + .0)
- Use network prefix as key, list of IPs as value
- Grouping is similar to "group anagrams" pattern

Key concepts:
- IP format: "192.168.1.100"
- Split by '.' to get parts: ["192", "168", "1", "100"]
- Network prefix: join first 3 parts + ".0" = "192.168.1.0"

Example:
```python
ip = "192.168.1.100"
parts = ip.split('.')
network = f"{parts[0]}.{parts[1]}.{parts[2]}.0"
# network = "192.168.1.0"
```

=== HINT LEVEL ===

Hint Level 2:

Detailed approach for _extract_network(ip):
1. Split IP string by '.' to get 4 parts
2. Take first 3 parts (indices 0, 1, 2)
3. Join them with '.' and add '.0' at the end
4. Return the network prefix string

Detailed approach for add_ip(ip):
1. Call _extract_network(ip) to get network prefix
2. Check if network exists in dictionary
3. If not, create empty list for that network
4. Append IP to the network's list

Detailed approach for get_network_count(network):
1. Check if network exists in dictionary
2. If yes, return length of list
3. If no, return 0

Detailed approach for get_all_networks():
1. Create result dictionary
2. Iterate through all networks
3. For each, map network to count (len of list)
4. Return result

Detailed approach for get_ips_in_network(network):
1. Check if network exists in dictionary
2. If yes, return the list of IPs
3. If no, return empty list

Edge cases:
- Empty classifier
- Non-existent network
- Multiple IPs in same network

=== HINT LEVEL ===

Hint Level 3:

Complete solution for __init__:
```python
def __init__(self):
    self.networks = {}
```

Complete solution for _extract_network:
```python
def _extract_network(self, ip: str) -> str:
    parts = ip.split('.')
    return f"{parts[0]}.{parts[1]}.{parts[2]}.0"
```

Complete solution for add_ip:
```python
def add_ip(self, ip: str) -> None:
    network = self._extract_network(ip)
    if network not in self.networks:
        self.networks[network] = []
    self.networks[network].append(ip)
```

Complete solution for get_network_count:
```python
def get_network_count(self, network: str) -> int:
    if network not in self.networks:
        return 0
    return len(self.networks[network])
```

Complete solution for get_all_networks:
```python
def get_all_networks(self) -> Dict[str, int]:
    return {network: len(ips) for network, ips in self.networks.items()}
```

Complete solution for get_ips_in_network:
```python
def get_ips_in_network(self, network: str) -> List[str]:
    return self.networks.get(network, [])
```

Time complexity:
- _extract_network: O(1)
- add_ip: O(1) amortized
- get_network_count: O(1)
- get_all_networks: O(n)
- get_ips_in_network: O(1)

Space complexity: O(n) where n is number of unique IPs
