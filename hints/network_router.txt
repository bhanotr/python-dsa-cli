1: === HINT LEVEL ===

Hint Level 1:

General approach:
- Use BFS (Breadth-First Search) for shortest path in unweighted graph
- BFS explores nodes level by level, guaranteeing shortest path
- Use queue (deque) for FIFO ordering
- Track visited nodes to avoid cycles
- Store parent of each node to reconstruct path

Key concepts:
- Start from start node, explore all neighbors first
- Then explore neighbors' neighbors, etc.
- First time we reach end node, we have shortest path
- Use parent dict to backtrack: {child: parent}

Example queue usage:
```python
from collections import deque
queue = deque([start_node])
node = queue.popleft()
queue.append(neighbor)
```

=== HINT LEVEL ===

Hint Level 2:

Detailed approach for bfs_shortest_path(graph, start, end):
1. If start == end, return [start]
2. Initialize visited = set([start])
3. Initialize queue = deque([start])
4. Initialize parent = {}
5. While queue not empty:
   a. Pop node from queue
   b. For each neighbor of node:
      - If neighbor not visited:
        * Add to visited
        * Set parent[neighbor] = node
        * Add to queue
        * If neighbor == end, break
6. Reconstruct path:
   - Start from end
   - Follow parent pointers back to start
   - Reverse path
7. Return path or [] if no path

Detailed approach for path reconstruction:
- Initialize path = []
- current = end
- While current in parent:
  - path.append(current)
  - current = parent[current]
- path.append(start)
- Reverse path

Edge cases:
- Start equals end
- No path exists
- Single node graph
- Disconnected components

=== HINT LEVEL ===

Hint Level 3:

Complete solution for bfs_shortest_path:
```python
def bfs_shortest_path(graph: Dict[int, List[int]], start: int, end: int) -> List[int]:
    if start == end:
        return [start]
    
    visited = set([start])
    queue = deque([start])
    parent = {}
    
    while queue:
        current = queue.popleft()
        
        for neighbor in graph.get(current, []):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor] = current
                queue.append(neighbor)
                
                if neighbor == end:
                    # Reconstruct path
                    path = [end]
                    node = end
                    while node != start:
                        node = parent[node]
                        path.append(node)
                    return path[::-1]
    
    return []
```

Time complexity: O(V + E)
- Each vertex visited at most once
- Each edge checked at most twice

Space complexity: O(V)
- Visited set: O(V)
- Queue: O(V) worst case
- Parent dict: O(V)

BFS guarantees shortest path in unweighted graphs because it explores in order of distance from start.
