=== HINT LEVEL ===

Hint Level 1:

General approach:
- url_encode(): Iterate through each character, if safe add as-is, otherwise encode as %XX
- url_decode(): Iterate through string, when you see '%', extract next 2 chars and convert to character
- is_valid_encoded(): Check that every '%' is followed by 2 valid hex digits

Key methods:
- ord(char) - gets ASCII value
- hex(value)[2:] - converts to hex string without '0x'
- char.zfill(2) - pads with zeros to 2 digits
- int(hex_str, 16) - converts hex string to integer

Example:
```python
# Encode '@'
char = '@'
hex_val = hex(ord('@'))[2:]  # '40'
encoded = '%' + hex_val  # '%40'
```

=== HINT LEVEL ===

Hint Level 2:

Detailed approach for url_encode():
1. Create result string
2. For each character in url:
   - If char is in SAFE_CHARS, add to result
   - Otherwise:
     - Get ASCII value with ord()
     - Convert to hex and remove '0x' prefix
     - Ensure 2 digits with zfill(2)
     - Add '%' + hex value to result
3. Return result

Detailed approach for url_decode():
1. Create result string and index i
2. While i < len(encoded_url):
   - If encoded_url[i] == '%':
     - Extract next 2 characters (i+1, i+2)
     - Convert from hex to integer with int(hex_str, 16)
     - Convert to character with chr()
     - Add to result, skip ahead (i += 3)
   - Else:
     - Add character as-is (i += 1)
3. Return result

Detailed approach for is_valid_encoded():
1. Iterate through encoded_url with index
2. When you see '%':
   - Check if at least 2 more characters exist
   - Check if both are valid hex digits (0-9, a-f, A-F)
   - If not, return False
3. Return True if all checks pass

=== HINT LEVEL ===

Hint Level 3:

Complete solution for url_encode():
```python
def url_encode(url: str) -> str:
    result = []
    for char in url:
        if char in SAFE_CHARS:
            result.append(char)
        else:
            hex_val = hex(ord(char))[2:].upper()
            hex_val = hex_val.zfill(2)
            result.append('%' + hex_val)
    return ''.join(result)
```

Complete solution for url_decode():
```python
def url_decode(encoded_url: str) -> str:
    result = []
    i = 0
    while i < len(encoded_url):
        if encoded_url[i] == '%' and i + 2 < len(encoded_url):
            hex_str = encoded_url[i+1:i+3]
            try:
                char_code = int(hex_str, 16)
                result.append(chr(char_code))
                i += 3
            except ValueError:
                result.append(encoded_url[i])
                i += 1
        else:
            result.append(encoded_url[i])
            i += 1
    return ''.join(result)
```

Complete solution for is_valid_encoded():
```python
def is_valid_encoded(encoded_url: str) -> bool:
    i = 0
    while i < len(encoded_url):
        if encoded_url[i] == '%':
            if i + 2 >= len(encoded_url):
                return False
            hex_str = encoded_url[i+1:i+3]
            if not all(c in '0123456789abcdefABCDEF' for c in hex_str):
                return False
            i += 3
        else:
            i += 1
    return True
```

Time complexity: O(n) for all functions
Space complexity: O(n) - building new strings
